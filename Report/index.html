<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="UTF-8">
    <script>
    </script>
    <link rel="stylesheet" href="foundation.css"/>
    <script src="../assets/js/modernizr.js"></script>
  </head>
  
  <body>

    <div class="row">
      <div class="large-12 columns">
        <div class="nav-bar right">
          <ul class="button-group">
            <li><a href="https://github.com/marcusrm/Tidal" class="button">Source Code</a></li>
            <li><a href="http://hci.ecn.purdue.edu/8008/08/" class="button">Tidal Interface Login</a></li>
            <li><a href="https://engineering.purdue.edu/~aq/695/15sp/" class="button">Purdue ECE695</a></li>
          </ul>
        </div>
        <h1>Tidal <small>join the rising tide</small></h1>
        <hr/>
      </div>
    </div>
    
    <div class="row">
      
      <div class="large-9 columns" role="content">
	
        <article>
	  
          <h3><a href="#">Interfacing with AMT</a></h3>
          <h6>Written by <a href="#">RJ Marcus</a> on April 12, 2015.</h6>
	  
          <div class="row">
            <div class="large-6 columns">
              <p>To ensure our system is thoroughly tested in a real-world environment, we decided to interface with AMT in order to build our pool of workers. Original tasks will still be manually generated by developers for now. In order to take advantage of AMT's existing resources, we interface with it usign an API called Crowdlib, written by Quinn and Bederson.  </p>
            </div>
            <div class="large-6 columns">
              <img src="http://placehold.it/400x240&text=[img]"/>
            </div>
          </div>
	  
          <p>Upon loading, our webserver will check how many existing HITs have been posted on AMT, and automatically generate new ones if a minimum number is not met. Additionally, whenever a worker logs in to our site, we generate a new HIT if our <i>Worker Manager</i> decides that it needs more workers. A worker only needs to take one HIT per "session", because they will stay inside that HIT's iframe on AMT, but they are completing multiple HITs on the local Tidal server. We decided that this would help improve the workflow on our site so workers had to do less page navigation.  </p>
          <p>A running total of the number of local HITs completed and total amount earned is always present in the corner of the worker's screen. The worker's pay accumulates as bonuses since they are technically only performing one HIT on AMT. This total is automatically saved to disk after each interaction with a worker in case the server crashes. The worker can logout at any time with the logout button, which will end their Tidal session, and generate a payout for the original HIT on AMT.</p>
	  
          <p>We hope that the idea of performing multiple HITs without immediate payment doesn't scare away too many workers. A tutorial hit will be required of each worker the first time they log in to our site which will explain how Tidal works and what it is. Hopefully this tutorial will help workers get a better understanding of what we're doing and encourage them to come back.</p>
	  
        </article>	
        <article>
	  
          <h3><a href="#">Managing Workers</a></h3>
          <h6>Written by <a href="#">Nikhil Jali</a> on April 10, 2015.</h6>
	  
          <div class="row">
            <div class="large-6 columns">

	      <p>The Worker Manager(WM) performs the task of managing an active worker pool, storing information regarding each worker and keeps track of remuneration. The WM is provided as a self-sufficient class with numerous methods that serve as APIs to the other modules in the project. For each worker, an instance of the worker class is instantiated. However, the interface is with the class itself thereby abstracting away the complexity of handling the low level information of each worker and the pool. The WM has the following functions:

            </div>
            <div class="large-6 columns">
              <img src="http://placehold.it/400x240&text=[img]"/>
            </div>
          </div>
	  
	  <ul>
	    <li><p>Worker addition and login: </p>
	      <p>For new workers sign-ups, an object is created in a database. The workers can then be logged in upon which they are added onto an idle list and their profile is made online. Similarly, if the worker or WM chooses to logout the worker after task completion, remuneration is provided and the worker is made offline. These are provided as APIs to the TM and Authentication Manager(AM). Also upon login, socket objects corresponding to each worker are stored within the worker class instance.</p>
	    </li>

	    <li><p>Worker Profile:  </p>
	      <p>Each worker's task completion history, remuneration and point system for how good a leafer, brancher or sapper is recorded. The worker profile is provided as a way of also motivating the worker with non-monetary incentives.</p>
	    </li>

	    <li><p>Active worker pool management:  </p>
	     <p> Maintaining an active on-demand worker pool is key to being able to complete tasks quickly. This is achieved by keeping the worker's HIT page open and indicating task assignment through alerts in the title of the page. Also, the WM is able to calculate if more workers would be required and interfaces with the AM to put out HITs on Amazon Mechanical Turk(AMT) to add workers to the pool. Similarly, an excess work-force is reduced by remunerating workers on task completion and logging them out.</p> 
	    </li>

	    <li><p>Worker assignment and task completion:  </p>
	      <p>This is provided as an API to the TM where specific type of workers can be requested for by providing a Task Id. Upon selecting an active, idle and type of worker, the Worker Id is returned to the TM.  At the same time, the Task Id is linked to the particular worker to keep track of what tasks are being assigned to each worker. Upon task completion, the Worker Id is returned to the idle pool waiting to be given additional tasks and the remuneration counter is updated. If the number of workers far exceed the number required to maintain a sufficient active pool, the excess workers upon task completion are remunerated and logged out of the system.</p>
	    </li>

        </article>

	
        <article>
	  
          <h3><a href="#">Managing Tasks</a></h3>
          <h6>Written by <a href="#">Shruthi Balakrishna</a> on April 9, 2015.</h6>
	  
          <div class="row">
            <div class="large-6 columns">
	      <p>Why do we need a task manager ?</p>
	      <p>The given task is broken down into several branches by Branch workers. These branch tasks are either broken down further or treated as an indivisible leaf task. A leaf task is completed by a worker(leafer) while the branch tasks split further. This structure is represented as a tree with each node representing a task.</p>

            </div>
            <div class="large-6 columns">
              <img src="http://placehold.it/400x240&text=[img]"/>
            </div>
          </div>

	  <p>Hence, there is a need to manage this tree structure and monitor each task for 4 conditions –
	    <ul>
	      <li>Branching</li>
	      <li>Completion</li>
	      <li>Rework</li>
	      <li>Approval</li>
	    </ul>
	  </p>

	  <p> These functions are carried out by the task manager. We limit the number of branches to 5 in order to maintain a fair pay and fair work policy. Have a greater number of branches disrupts the balance of branch-leaf workers and does not compliment our design.</p>
          
        </article>
	
	
        <article>
	  
          <h3><a href="#">Authentication</a></h3>
          <h6>Written by <a href="#">RJ Marcus</a> on April 8, 2015.</h6>
	  
          <div class="row">
            <div class="large-6 columns">
	      <p>In order to protect our site from spam, unwanted responses, and general attacks, we decided to use tornado’s built in authenticator to screen our visitors before allowing them to enter. This functionality is very elegant and simple to use because the programmer only needs to include an “@authenticated” decorator at the beginning of a request handler class in order to check to see if the requester has the necessary cookies to be viewing the page.  The tricky part of this implementation is distributing cookies. </p>

            </div>
            <div class="large-6 columns">
              <img src="http://placehold.it/400x240&text=[img]"/>
            </div>
          </div>
	  
	  <p>When accessing the site through any normal URL the user will be redirected to the login page, which is meant for requesters and developers to log into the backend of the site. Here a secure cookie is given to the user once they log in with the correct username and password. The username and password are verified for correct string characteristics before being used in a query (enough characters, no special characters, etc.). Usernames and passwords are kept in a separate database and placeholders are used in queries to this database. </p>
	  <p>On the other hand, GETs from workers that come from amazon are expected to enter through a specific URL suffix “/hit/”. Workers will be automatically handed a cookie based on their workerID and the hitID for the HIT they are performing. This cookie allows them to stay within the “/hit/” portion of the website and expires when they leave the site. </p>
	  
        </article>
	
        <article>
	  
          <h3><a href="#">Basic Design</a></h3>
          <h6>Written by <a href="#">RJ, Shruthi, Nikhil</a> on April 8, 2015.</h6>


	  <section>
    	    <p>
	      For our project we plan to create an automated programming platform which takes complex programming tasks (likely in JavaScript) and recursively divides the work until workers are able to complete the task by individually writing simple functions.  Many ideas concerning worker retention, hierarchies, and motivation were brought up in “The Future of Crowd Work”. We plan to adapt many of these ideas into the current platform designed by Turkomatic, which is already organized in a hierarchical fashion, with “branch” workers breaking up and delegating tasks to other workers further down the subtree. Let us call this hierarchy a “task-tree”, where workers who recursively divide up tasks are called “branchers”, workers who finish a task are “leafers”, and workers who recombine completed tasks are “sappers”. 
	      This method of “divide and conquer” work-flow is will implement a novel form of 2-level supervision where branch-workers must approve the any actions of their branch-designated children. Essentially, as the tree grows each new node must be approved by its parent and grandparent before being released as a hit. This means that branch workers must remain on the site for a while until their grandchildren are ready to be approved. However, this will not be a problem because while each brancher waits, they are required to write code stubs for each child as well as any test-case programs that they can create before their children finish branching. The stubs are given to leaf-children to assist with implementing code, while test programs are given to future sappers who will recombine the code at this level of the tree. 
	      <figure style="float:left">
		<img src="worker_tasks.jpg"  alt="Failed to load img " class="taskimg" id="mypic" > 
		<figcaption align="middle">Table1 : Ranking parameters for tasks in each category</figcaption>
	      </figure>
	      On the other hand, sappers are able to use the test cases developed by the original brancher, as well as see the original input and output requests that were made for this level in the tree. Sappers can give feedback on the quality of the work from both leafers and branchers. Sappers are penalized if their work is rejected further up the tree by sappers closer to the root node.  Currently this is the only way to get feedback for sappers since no other worker class can observe their work. This method encourages branching workers to create easily followed instructions, improves the decision making of the entire tree, and helps make more uniformly structured code.
	      The question was raised in the “future of crowd work” as to whether or not workers should choose jobs, or platforms should push jobs. We aim to mix the two options by allowing users to choose which jobs they prefer (either branching, leafing, or sapping), but we will rank workers within each field so that we can give the most important jobs to the best workers. For example, when starting a tree we will offer the root node to the best branching workers we have available. Turkomatic noted that they saw great improvements in their task-tree when the first few branches were made by professionals or workers with great care (and also immediate degradation in quality with a lazy brancher early on). 
	      The ranks of the workers will be determined on a “point” based system, which improves the feedback and rewards for branch-workers. Table 1 shows a loose idea of what some categories might be that help determine the points each worker can score per HIT.

	      This system also leaves a great amount of room for including AI practices and machine learning algorithms that could take advantage of other information to help us guide workers to where they will be most efficient in their chosen field, and how much to reward them</p>
	    <p style="clear:both">
	      <b style="font-size: 30px;">Design Implementation Overview</b><br>
	      <figure style="float:left">
		<img src="wireframe.jpg" style="padding-right:10px" alt="Failed to load img " class="taskimg" id="mypic" > 
		<figcaption align="middle">Fig1 : Wireframe of the task design</figcaption>
	      </figure>
	      The wireframe for the design we have in mind is shown on Fig1. 
	      Workers choose whether they want be branchers, sappers, or leafers before they are automatically given tasks for their chosen field.
	      HITs are automatically chosen for workers who will “preview” the HIT before deciding whether they want to accept it or not. 
	      As workers accumulate more and more points they will be automatically given higher priority HITs (e.g. branch nodes that are closer to the root), which should improve the overall performance of future task-trees.
	      Branch workers can only branch a maximum number of children (TBD, likely 5). 
	      Branch workers will say whether their child tasks are branches or leaves upon creation. 
	      Branchers have to approve the tasks that their child processes attempt to spawn. 
	      Branchers have to write stubs for each function that they request and while they’re waiting to supervise they will write test cases. This added work will give branchers a good reason to stay around long enough to supervise their children. 
	      If we use something like JS/python then we can test compiling in the browser. The leafer can get the test case and use it to test their stuff before they submit it to the sapper (we have to tell them though that the test cases might not be correct and they can submit even though it doesn’t pass the brancher’s test). 
	      Sappers can rate branchers on how well the test cases helped them debug. This could lead to a “checks and balances” type system between brancher/sapper/leafer.
	      Payment: BASE_PAY + (score_for_this_hit / max_score_per_hit) * score_bonus
	      Sappers are recombining the programs at each node back up the tree to make sure everything compiles and actually does what it say it does. If they encounter a problem then they identify which child gave a bad output and we will respawn that subtree. We will do some penalization on that faulty subtree.  
	      If a leaf gets starved out then we increase the pay over time to some max amount. Then if nobody still takes it until a max timer runs out we then give it back out at a branch task (the root of a new tree, because their supervisors left already). Branchers who approve tasks that get starved out will get negative points.
	    </p>

	  </section>


	  
        </article>
	 <article>
              <h3><a href="#">References</a></h3>
          <p>
		    <ol>
    <li>Hsiao, H.M., Po-san, W. (2006). <cite>Lifestyle and class: The experiences of cultural globalization in Taipei and Hong Kong</cite>. Korea Observer, 37(1), 181-216.</li>
    <li>Hsu, J. (2005). <cite>A site of transnationalism in the “Ungrounded Empire”: Taipei as an interface city in the cross-border business networks</cite>. Geoforum, 36, 654-666.</li>
    <li>Huang, S., Chen, C. (2009). <cite>Urbanization and socioeconomic metabolism in Taipei: An energy synthesis</cite>. Journal of Industrial Ecology, 13(1), 75-93.</li>
    <li>Huang, T. (2006). <cite>The cosmopolitan imaginary and flexible identities of global city-regions: articulating new cultural identities in Taipei and Shanghai</cite>. Inter-Asia Cultural Studies, 7(3), 472-491.</li>
    <li><cite><a href="https://www.cia.gov/library/publications/the-world-factbook/geos/tw.html">The World Factbook</a></cite>. (2009). Central Intelligence Agency. Retrieved November 22nd, 2010.</li>
  </ol>
		  
		  </p>
	  
        </article>	
        <hr/>
	
      </div>
      
      
      
      
      
      
      <aside class="large-3 columns">
	
		<div class="panel">

        <ul class="side-nav">
		        <h5>Main Modules</h5>
          <li><a href="AMTInt.html">•AMT Interfacing</a></li>
		  <li><a href="Auth.html">  •Authentication</a></li>
          <li><a href="Design.html">•Design Implementation</a></li>
          <li><a href="Task.html">  •Task Management</a></li>
		  <li><a href="Work.html">  •Worker Management</a></li>
        </ul>
		<a href="index.html">Main Page...</a>
		</div>
	
        <div class="panel">
          <h5>Who we are:</h5>
          <ul class="side-nav">
          <li><a href="http://web.ics.purdue.edu/~njali/">Nikhil Jali</a></li>
          <li><a href="http://web.ics.purdue.edu/~rmarcus/">Richard Marcus (RJ)</a></li>
          <li><a href="http://web.ics.purdue.edu/~balakrs/">Shruthi Balakrishna</a></li>
        </ul>
        </div>
	
      </aside>
      
      
    </div>
    

    
    
    
    <footer class="row">
      <div class="large-12 columns">
        <hr/>
        <div class="row">
          <div class="large-6 columns">
            <p>©2015, Nikhil, Richard & Shruthi. All rights reserved.<br>Created using with zurb.com.</p>
          </div>
          <div class="large-6 columns">
            <ul class="inline-list right">
	      <li><a href="https://github.com/marcusrm/Tidal" >Source Code</a></li>
              <li><a href="http://hci.ecn.purdue.edu/8008/08/" >Tidal Interface Login</a></li>
              <li><a href="https://engineering.purdue.edu/~aq/695/15sp/" >ECE695 Course Website</a></li>
            </ul>
          </div>
        </div>
      </div>
    </footer>
  </body>
</html>

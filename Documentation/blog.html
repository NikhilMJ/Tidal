<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="UTF-8">
    <script>
    </script>
    <link rel="stylesheet" href="foundation.css"/>
    <script src="../assets/js/modernizr.js"></script>
  </head>
  
  <body>

    <div class="row">
      <div class="large-12 columns">
        <div class="nav-bar right">
          <ul class="button-group">
            <li><a href="https://github.com/marcusrm/Tidal" class="button">Source Code</a></li>
            <li><a href="http://hci.ecn.purdue.edu/8008/08/" class="button">Tidal Login</a></li>
            <li><a href="https://engineering.purdue.edu/~aq/695/15sp/" class="button">ECE695 CPS</a></li>
          </ul>
        </div>
        <h1>Tidal <small>join the rising tide</small></h1>
        <hr/>
      </div>
    </div>
    
    <div class="row">
      
      <div class="large-9 columns" role="content">
	
        <article>
	  
          <h3><a href="#">Interfacing with AMT</a></h3>
          <h6>Written by <a href="#">RJ Marcus</a> on April 12, 2015.</h6>
	  
          <div class="row">
            <div class="large-6 columns">
              <p>To ensure our system is thoroughly tested in a real-world environment, we decided to interface with AMT in order to build our pool of workers. Original tasks will still be manually generated by developers for now. In order to take advantage of AMT's existing resources, we interface with it usign an API called Crowdlib [#], written by Quinn and Bederson.  </p>
            </div>
            <div class="large-6 columns">
              <img src="http://placehold.it/400x240&text=[img]"/>
            </div>
          </div>
	  
              <p>Upon loading, our webserver will check how many existing HITs have been posted on AMT, and automatically generate new ones if a minimum number is not met. Additionally, whenever a worker logs in to our site, we generate a new HIT if our <i>Worker Manager</i> decides that it needs more workers. A worker only needs to take one HIT per "session", because they will stay inside that HIT's iframe on AMT, but they are completing multiple HITs on the local Tidal server. We decided that this would help improve the workflow on our site so workers had to do less page navigation.  </p>
          <p>A running total of the number of local HITs completed and total amount earned is always present in the corner of the worker's screen. The worker's pay accumulates as bonuses since they are technically only performing one HIT on AMT. This total is automatically saved to disk after each interaction with a worker in case the server crashes. The worker can logout at any time with the logout button, which will end their Tidal session, and generate a payout for the original HIT on AMT.</p>
	  
          <p>We hope that the idea of performing multiple HITs without immediate payment doesn't scare away too many workers. A tutorial hit will be required of each worker the first time they log in to our site which will explain how Tidal works and what it is. Hopefully this tutorial will help workers get a better understanding of what we're doing and encourage them to come back.</p>
	  
        </article>	
        <article>
	  
          <h3><a href="#">Managing Workers</a></h3>
          <h6>Written by <a href="#">Nikhil Jali</a> on April 10, 2015.</h6>
	  
          <div class="row">
            <div class="large-6 columns">
              <p>Bacon ipsum dolor sit amet nulla ham qui sint exercitation eiusmod commodo, chuck duis velit. Aute in reprehenderit, dolore aliqua non est magna in labore pig pork biltong. Eiusmod swine spare ribs reprehenderit culpa.</p>
              <p>Boudin aliqua adipisicing rump corned beef. Nulla corned beef sunt ball tip, qui bresaola enim jowl. Capicola short ribs minim salami nulla nostrud pastrami.</p>
            </div>
            <div class="large-6 columns">
              <img src="http://placehold.it/400x240&text=[img]"/>
            </div>
          </div>
	  
          <p>Pork drumstick turkey fugiat. Tri-tip elit turducken pork chop in. Swine short ribs meatball irure bacon nulla pork belly cupidatat meatloaf cow. Nulla corned beef sunt ball tip, qui bresaola enim jowl. Capicola short ribs minim salami nulla nostrud pastrami. Nulla corned beef sunt ball tip, qui bresaola enim jowl. Capicola short ribs minim salami nulla nostrud pastrami.</p>
	  
          <p>Pork drumstick turkey fugiat. Tri-tip elit turducken pork chop in. Swine short ribs meatball irure bacon nulla pork belly cupidatat meatloaf cow. Nulla corned beef sunt ball tip, qui bresaola enim jowl. Capicola short ribs minim salami nulla nostrud pastrami.</p>
	  
        </article>

	
        <article>
	  
          <h3><a href="#">Managing Tasks</a></h3>
          <h6>Written by <a href="#">Shruthi Balakrishna</a> on April 9, 2015.</h6>
	  
          <div class="row">
            <div class="large-6 columns">
	      <p>Why do we need a task manager ?</p>
	      <p>The given task is broken down into several branches by Branch workers. These branch tasks are either broken down further or treated as an indivisible leaf task. A leaf task is completed by a worker(leafer) while the branch tasks split further. This structure is represented as a tree with each node representing a task.</p>

            </div>
            <div class="large-6 columns">
              <img src="http://placehold.it/400x240&text=[img]"/>
            </div>
          </div>

	      <p>Hence, there is a need to manage this tree structure and monitor each task for 4 conditions –
		<ul>
		  <li>Branching</li>
		  <li>Completion</li>
		  <li>Rework</li>
		  <li>Approval</li>
		</ul>
	      </p>

	      <p> These functions are carried out by the task manager. We limit the number of branches to 5 in order to maintain a fair pay and fair work policy. Have a greater number of branches disrupts the balance of branch-leaf workers and does not compliment our design.</p>
              
        </article>
	
	
        <article>
	  
          <h3><a href="#">Authentication</a></h3>
          <h6>Written by <a href="#">RJ Marcus</a> on April 8, 2015.</h6>
	  
          <div class="row">
            <div class="large-6 columns">
	      <p>In order to protect our site from spam, unwanted responses, and general attacks, we decided to use tornado’s built in authenticator to screen our visitors before allowing them to enter. This functionality is very elegant and simple to use because the programmer only needs to include an “@authenticated” decorator at the beginning of a request handler class in order to check to see if the requester has the necessary cookies to be viewing the page.  The tricky part of this implementation is distributing cookies. </p>

            </div>
            <div class="large-6 columns">
              <img src="http://placehold.it/400x240&text=[img]"/>
            </div>
          </div>
	  
	  <p>When accessing the site through any normal URL the user will be redirected to the login page, which is meant for requesters and developers to log into the backend of the site. Here a secure cookie is given to the user once they log in with the correct username and password. The username and password are verified for correct string characteristics before being used in a query (enough characters, no special characters, etc.). Usernames and passwords are kept in a separate database and placeholders are used in queries to this database. </p>
	  <p>On the other hand, GETs from workers that come from amazon are expected to enter through a specific URL suffix “/hit/”. Workers will be automatically handed a cookie based on their workerID and the hitID for the HIT they are performing. This cookie allows them to stay within the “/hit/” portion of the website and expires when they leave the site. </p>
	  
        </article>
	
        <article>
	  
          <h3><a href="#">Basic Design</a></h3>
          <h6>Written by <a href="#">RJ, Shruthi, Nikhil</a> on April 8, 2015.</h6>


	  <section>
    	    <p>
	      For our project we plan to create an automated programming platform which takes complex programming tasks (likely in JavaScript) and recursively divides the work until workers are able to complete the task by individually writing simple functions.  Many ideas concerning worker retention, hierarchies, and motivation were brought up in “The Future of Crowd Work”. We plan to adapt many of these ideas into the current platform designed by Turkomatic, which is already organized in a hierarchical fashion, with “branch” workers breaking up and delegating tasks to other workers further down the subtree. Let us call this hierarchy a “task-tree”, where workers who recursively divide up tasks are called “branchers”, workers who finish a task are “leafers”, and workers who recombine completed tasks are “sappers”. 
	      This method of “divide and conquer” work-flow is will implement a novel form of 2-level supervision where branch-workers must approve the any actions of their branch-designated children. Essentially, as the tree grows each new node must be approved by its parent and grandparent before being released as a hit. This means that branch workers must remain on the site for a while until their grandchildren are ready to be approved. However, this will not be a problem because while each brancher waits, they are required to write code stubs for each child as well as any test-case programs that they can create before their children finish branching. The stubs are given to leaf-children to assist with implementing code, while test programs are given to future sappers who will recombine the code at this level of the tree. 
	      <figure style="float:left">
		<img src="worker_tasks.jpg"  alt="Failed to load img " class="taskimg" id="mypic" > 
		<figcaption align="middle">Table1 : Ranking parameters for tasks in each category</figcaption>
	      </figure>
	      On the other hand, sappers are able to use the test cases developed by the original brancher, as well as see the original input and output requests that were made for this level in the tree. Sappers can give feedback on the quality of the work from both leafers and branchers. Sappers are penalized if their work is rejected further up the tree by sappers closer to the root node.  Currently this is the only way to get feedback for sappers since no other worker class can observe their work. This method encourages branching workers to create easily followed instructions, improves the decision making of the entire tree, and helps make more uniformly structured code.
	      The question was raised in the “future of crowd work” as to whether or not workers should choose jobs, or platforms should push jobs. We aim to mix the two options by allowing users to choose which jobs they prefer (either branching, leafing, or sapping), but we will rank workers within each field so that we can give the most important jobs to the best workers. For example, when starting a tree we will offer the root node to the best branching workers we have available. Turkomatic noted that they saw great improvements in their task-tree when the first few branches were made by professionals or workers with great care (and also immediate degradation in quality with a lazy brancher early on). 
	      The ranks of the workers will be determined on a “point” based system, which improves the feedback and rewards for branch-workers. Table 1 shows a loose idea of what some categories might be that help determine the points each worker can score per HIT.

	      This system also leaves a great amount of room for including AI practices and machine learning algorithms that could take advantage of other information to help us guide workers to where they will be most efficient in their chosen field, and how much to reward them</p>
	    <p style="clear:both">
	      <b style="font-size: 30px;">Design Implementation Overview</b><br>
	      <figure style="float:left">
		<img src="wireframe.jpg" style="padding-right:10px" alt="Failed to load img " class="taskimg" id="mypic" > 
		<figcaption align="middle">Fig1 : Wireframe of the task design</figcaption>
	      </figure>
	      The wireframe for the design we have in mind is shown on Fig1. 
	      Workers choose whether they want be branchers, sappers, or leafers before they are automatically given tasks for their chosen field.
	      HITs are automatically chosen for workers who will “preview” the HIT before deciding whether they want to accept it or not. 
	      As workers accumulate more and more points they will be automatically given higher priority HITs (e.g. branch nodes that are closer to the root), which should improve the overall performance of future task-trees.
	      Branch workers can only branch a maximum number of children (TBD, likely 5). 
	      Branch workers will say whether their child tasks are branches or leaves upon creation. 
	      Branchers have to approve the tasks that their child processes attempt to spawn. 
	      Branchers have to write stubs for each function that they request and while they’re waiting to supervise they will write test cases. This added work will give branchers a good reason to stay around long enough to supervise their children. 
	      If we use something like JS/python then we can test compiling in the browser. The leafer can get the test case and use it to test their stuff before they submit it to the sapper (we have to tell them though that the test cases might not be correct and they can submit even though it doesn’t pass the brancher’s test). 
	      Sappers can rate branchers on how well the test cases helped them debug. This could lead to a “checks and balances” type system between brancher/sapper/leafer.
	      Payment: BASE_PAY + (score_for_this_hit / max_score_per_hit) * score_bonus
	      Sappers are recombining the programs at each node back up the tree to make sure everything compiles and actually does what it say it does. If they encounter a problem then they identify which child gave a bad output and we will respawn that subtree. We will do some penalization on that faulty subtree.  
	      If a leaf gets starved out then we increase the pay over time to some max amount. Then if nobody still takes it until a max timer runs out we then give it back out at a branch task (the root of a new tree, because their supervisors left already). Branchers who approve tasks that get starved out will get negative points.
	    </p>

	  </section>


	  
        </article>
	
        <hr/>
	
      </div>
      
      
      
      
      
      
      <aside class="large-3 columns">
	
        <h5>Categories</h5>
        <ul class="side-nav">
          <li><a href="#">News</a></li>
          <li><a href="#">Code</a></li>
          <li><a href="#">Design</a></li>
          <li><a href="#">Fun</a></li>
          <li><a href="#">Weasels</a></li>
        </ul>
	
        <div class="panel">
          <h5>Featured</h5>
          <p>Pork drumstick turkey fugiat. Tri-tip elit turducken pork chop in. Swine short ribs meatball irure bacon nulla pork belly cupidatat meatloaf cow.</p>
          <a href="#">Read More →</a>
        </div>
	
      </aside>
      
      
    </div>
    
    
    
    
    
    
    <footer class="row">
      <div class="large-12 columns">
        <hr/>
        <div class="row">
          <div class="large-6 columns">
            <p>© Copyright no one at all. Go to town.</p>
          </div>
          <div class="large-6 columns">
            <ul class="inline-list right">
	      <li><a href="https://github.com/marcusrm/Tidal" >Source Code</a></li>
              <li><a href="http://hci.ecn.purdue.edu/8008/08/" >Tidal Login</a></li>
              <li><a href="https://engineering.purdue.edu/~aq/695/15sp/" >ECE695 CPS</a></li>
            </ul>
          </div>
        </div>
      </div>
    </footer>
  </body>
</html>
